# Lazy Text Evaluation

To understand Lazy Text Evaluation, let's walk through a common task performed, perhaps, millions of times per day. Imagine if you were courier tasked with delivering a package to a particular house located somewhere within an area spanning multiple cities. What would be your? Would you go city by city, block by block, house by house in order to find the one you are looking for? Well, if you did go city to city, block by block, house by house there is no doubt you'd eventually accomplish your goal. That said, it wouldn't be the most efficient way of performing said task. The most efficient way, however, would be to require and enforce that each package have a shipping address prior to attempting delivery so that you can use your groovy GPS device to find the exact location. It would also, perhaps, make sense that the package come with some instructions on how best to handle its contents upon receipt.

Now apply this same logic to the problem at hand, that is, querying a document structure looking for a particular data field. Think about how inefficient it would be to randomly scan a document structure looking for a particular data field when the structure of said document is known upfront. Unfortunately, most modern parsers walk the document structure in search for matches. We found this to be both tedious and strange considering how the human mind works. Think about how one would query a relational database. Since as far back as the 1970's, the world has become accustom to using Structured Query Language--better know as SQL--to query relational databases in search for specific data. Machete's genius is that it treats structured documents in much the same way as relational databases treat their relational data, that is, it enables queries to be executed against a predefined schema in the most efficient manner possible, which is lazily.

When you execute a query against a relational database, the database engine will generate a execution plan so that it takes the most efficient path to executing the query. Machete's parsing engine functions in a similar manner. Once the execution plan has been provided \(see _**figure 1**_\), the parser will orient itself within the document structure, extract the data from the specified fields and parse them into a set of predefined entities per the object mapper. As a result, Machete is said to parse data lazily. _Lazy Text Evaluation_, aka _lazy parsing_, is the core reason why Machete is so performant.![](/assets/LazyTextEvaluation1.png)**Figure 1**

Lazy Text Evaluation describes the process of of applying mapping rules to text during query execution. Correlating this back to the analogy,

![](/assets/MacheteParsingEngine.png)

To be clear, calling the _Parse_ method does not actually parse the document structure in the way you might think. It is minimalistic in that only the boundaries \(i.e. end of line\) of the entity are discovered initially. That said, you'll see that calling _Parse_ returns an _EntityResult_ rather than an actual parsed object structure. There is a reason for this, that is, we haven't told the parser what exactly we would like it to parse yet. Remember, parsing in Machete is done lazily, therefore, the entity maps are not actually called when the _Parse_ method is called. Once a query is performed against the document structure, only then are entity maps called to convert the parsed text into entities.

![](/assets/LazyParsing.png)

